<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Viewport settings to prevent zooming on mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Universal Hand-Tracked Pong</title>
    
    <!-- Retro Font -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <!-- MediaPipe Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        /* --- CORE STYLING --- */
        :root {
            --bg-color: #050505;
            --text-color: #ffffff;
            --accent-color: #4CAF50;
        }

        body {
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
            background-color: var(--bg-color);
            font-family: 'Press Start 2P', cursive;
            color: var(--text-color);
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* Prevent pinch zoom */
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background-color: #000;
            image-rendering: pixelated;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            /* Ensure canvas fits perfectly */
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Essential for iOS: Hide video but keep it in DOM */
        .input_video {
            display: none;
            position: absolute;
            top: 0; left: 0;
        }

        /* --- UI OVERLAYS --- */
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .hidden { display: none !important; }

        h1 {
            font-size: 8vw; /* Responsive font size */
            margin-bottom: 10px;
            text-shadow: 4px 4px 0px #333;
            text-align: center;
        }

        @media (min-width: 800px) { h1 { font-size: 60px; } }

        .subtitle {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 30px;
            text-transform: uppercase;
            text-align: center;
            line-height: 1.5;
            padding: 0 20px;
        }

        /* Settings Grid */
        .settings-box {
            background: #1a1a1a;
            padding: 20px;
            border: 4px solid #fff;
            margin-bottom: 20px;
            text-align: center;
            max-width: 90%;
        }

        .setting-row {
            margin: 15px 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 300px;
            max-width: 100%;
        }

        .setting-label {
            font-size: 10px;
            color: #ccc;
            text-align: left;
            flex: 1;
        }

        .setting-options {
            display: flex;
            gap: 5px;
        }

        button.opt-btn {
            background: #333;
            border: 2px solid #555;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            padding: 8px 10px;
            cursor: pointer;
        }

        button.opt-btn.active {
            background: #fff;
            color: #000;
            border-color: #fff;
        }
        
        button.opt-btn[data-theme="cyber"].active {
            background: linear-gradient(90deg, #FF0055 0%, #00AAFF 100%);
            color: white;
            border-color: #fff;
        }

        .start-btn {
            background: var(--accent-color);
            border: 4px solid #2E7D32;
            color: white;
            font-family: 'Press Start 2P', cursive;
            font-size: 18px;
            padding: 15px 25px;
            cursor: pointer;
            margin-top: 10px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .spinner {
            width: 40px; height: 40px;
            border: 4px solid #333;
            border-top: 4px solid #0f0;
            margin-bottom: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* --- MOBILE ORIENTATION LOCK --- */
        #orientation-lock {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            z-index: 9999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
        }

        /* Show warning only on Portrait screens */
        @media screen and (orientation: portrait) {
            #orientation-lock { display: flex; }
            #game-container { display: none; }
        }

    </style>
</head>
<body>

    <!-- Orientation Warning for Mobile -->
    <div id="orientation-lock">
        <div style="font-size: 50px; margin-bottom: 20px;">â†»</div>
        <p style="line-height: 1.5; font-size: 12px; padding: 20px;">
            PLEASE ROTATE DEVICE<br>TO LANDSCAPE
        </p>
    </div>

    <!-- Hidden Video: playsinline is CRITICAL for iOS -->
    <video class="input_video" playsinline webkit-playsinline></video>

    <div id="game-container">
        <canvas id="pongCanvas"></canvas>

        <!-- Loading -->
        <div id="loading-screen" class="overlay">
            <div class="spinner"></div>
            <div style="font-size: 10px; line-height: 1.8; text-align: center;">
                INITIALIZING AI...<br>
                <span style="color: #666">Please Allow Camera Access</span>
            </div>
        </div>

        <!-- Start Menu -->
        <div id="start-screen" class="overlay hidden">
            <h1>PONG</h1>
            <div class="subtitle">Hand Tracking Edition</div>

            <div class="settings-box">
                <div class="setting-row">
                    <span class="setting-label">TIME</span>
                    <div class="setting-options">
                        <button class="opt-btn active" onclick="setCfg('time', 60, this)">60s</button>
                        <button class="opt-btn" onclick="setCfg('time', -1, this)">Inf</button>
                    </div>
                </div>
                <div class="setting-row">
                    <span class="setting-label">SCORE</span>
                    <div class="setting-options">
                        <button class="opt-btn active" onclick="setCfg('score', 5, this)">5</button>
                        <button class="opt-btn" onclick="setCfg('score', 10, this)">10</button>
                    </div>
                </div>
                <div class="setting-row">
                    <span class="setting-label">THEME</span>
                    <div class="setting-options">
                        <button class="opt-btn active" onclick="setCfg('theme', 'classic', this)">Retro</button>
                        <button class="opt-btn" data-theme="cyber" onclick="setCfg('theme', 'cyber', this)">Cyber</button>
                    </div>
                </div>
            </div>

            <button class="start-btn" onclick="startGame()">START</button>
        </div>

        <!-- Game Over -->
        <div id="game-over-screen" class="overlay hidden">
            <h1 id="winner-text" style="font-size: 30px;">GAME OVER</h1>
            <div class="subtitle" id="final-score-text" style="font-size: 20px; color: #fff;">0 - 0</div>
            <button class="start-btn" onclick="showMenu()">MENU</button>
        </div>
    </div>

    <script>
        // --- 1. DEVICE DETECTION & OPTIMIZATION ---
        // Detect mobile to lower AI complexity and resolution
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        console.log("Device detected as Mobile:", isMobile);

        // --- 2. GAME SETUP ---
        const canvas = document.getElementById('pongCanvas');
        const ctx = canvas.getContext('2d');
        const videoElement = document.getElementsByClassName('input_video')[0];

        let config = { timeLimit: 60, winScore: 5, theme: 'classic' };
        let gameState = { screen: 'loading', p1Score: 0, p2Score: 0, timeLeft: 0, startTime: 0, animationFrameId: null };

        // Relative Units (Percentage of Screen) for responsiveness
        let unit = 0; // 1% of height
        let player1 = {}, player2 = {}, ball = {};

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Recalculate units
            unit = canvas.height / 100;

            const pWidth = isMobile ? 3 * unit : 2 * unit; // Thicker paddles on mobile
            const pHeight = 20 * unit;
            const bSize = 3 * unit;
            const offset = 5 * unit;

            player1 = { ...player1, x: offset, width: pWidth, height: pHeight, color: '#fff' };
            player2 = { ...player2, x: canvas.width - offset - pWidth, width: pWidth, height: pHeight, color: '#fff' };
            
            // Keep paddles on screen during resize
            if(!player1.y) player1.y = (canvas.height/2) - (pHeight/2);
            if(!player2.y) player2.y = (canvas.height/2) - (pHeight/2);

            ball = { ...ball, size: bSize, color: '#fff' };
            if(ball.x === undefined) { ball.x = canvas.width/2; ball.y = canvas.height/2; ball.vx = 0; ball.vy = 0; }
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- 3. COMPUTER VISION SETUP ---
        
        let inputP1 = 0.5;
        let inputP2 = 0.5;

        function onResults(results) {
            // Remove loading screen on first successful frame
            if (gameState.screen === 'loading') {
                document.getElementById('loading-screen').classList.add('hidden');
                document.getElementById('start-screen').classList.remove('hidden');
                gameState.screen = 'menu';
            }

            if (results.multiHandLandmarks) {
                for (let index = 0; index < results.multiHandLandmarks.length; index++) {
                    const classification = results.multiHandedness[index];
                    const isRightHand = classification.label === 'Right';
                    const isLeftHand = classification.label === 'Left';
                    
                    // Tip of Index Finger
                    const rawY = results.multiHandLandmarks[index][8].y;

                    // Optimized Mapping: Map 20%-80% screen space to full paddle range
                    // This allows users to move paddle fully without hand leaving camera view
                    const minR = 0.2;
                    const maxR = 0.8;
                    let y = (rawY - minR) / (maxR - minR);
                    y = Math.max(0, Math.min(1, y));

                    if (isLeftHand) inputP1 = y;
                    if (isRightHand) inputP2 = y;
                }
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            // Optimization: Use Lite model (0) for Mobile, Full (1) for Desktop
            modelComplexity: isMobile ? 0 : 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5,
            selfieMode: true
        });

        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            // Optimization: Lower resolution for mobile to keep FPS high
            width: isMobile ? 480 : 1280,
            height: isMobile ? 360 : 720
        });
        camera.start();

        // --- 4. GAME LOGIC ---

        function setCfg(type, val, btn) {
            if (type === 'time') config.timeLimit = val;
            if (type === 'score') config.winScore = val;
            if (type === 'theme') config.theme = val;
            
            const parent = btn.parentElement;
            Array.from(parent.children).forEach(c => c.classList.remove('active'));
            btn.classList.add('active');
        }

        function startGame() {
            gameState.p1Score = 0;
            gameState.p2Score = 0;
            gameState.screen = 'playing';
            
            if (config.timeLimit > 0) {
                gameState.timeLeft = config.timeLimit;
                gameState.startTime = Date.now();
            } else {
                gameState.timeLeft = Infinity;
            }

            // Colors
            const isCyber = config.theme === 'cyber';
            player1.color = isCyber ? '#FF0055' : '#fff';
            player2.color = isCyber ? '#00AAFF' : '#fff';
            ball.color = '#fff';

            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            
            resetBall();
            loop();
        }

        function showMenu() {
            cancelAnimationFrame(gameState.animationFrameId);
            gameState.screen = 'menu';
            document.getElementById('start-screen').classList.remove('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
        }

        function resetBall() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            
            // Speed scaled by screen width
            const baseSpeed = canvas.width * 0.008; 
            const angle = (Math.random() * Math.PI / 4) - (Math.PI / 8);
            const direction = Math.random() > 0.5 ? 1 : -1;

            ball.vx = baseSpeed * Math.cos(angle) * direction;
            ball.vy = baseSpeed * Math.sin(angle);
        }

        function endGame(winner) {
            gameState.screen = 'gameover';
            cancelAnimationFrame(gameState.animationFrameId);
            const wText = winner === 'Tie' ? "DRAW" : (winner === 'P1' ? "P1 WINS" : "P2 WINS");
            document.getElementById('winner-text').innerText = wText;
            document.getElementById('final-score-text').innerText = `${gameState.p1Score} - ${gameState.p2Score}`;
            document.getElementById('game-over-screen').classList.remove('hidden');
        }

        function update() {
            const lerp = 0.2;
            
            // Paddle Movement
            const tY1 = inputP1 * (canvas.height - player1.height);
            player1.y += (tY1 - player1.y) * lerp;

            const tY2 = inputP2 * (canvas.height - player2.height);
            player2.y += (tY2 - player2.y) * lerp;

            // Ball Physics
            ball.x += ball.vx;
            ball.y += ball.vy;

            // Bounce Top/Bottom
            if (ball.y <= 0 || ball.y + ball.size >= canvas.height) {
                ball.vy = -ball.vy;
                ball.y = ball.y <= 0 ? 0 : canvas.height - ball.size; // Clamp
            }

            // Collision Helper
            function checkCol(b, p) {
                return (b.x < p.x + p.width && b.x + b.size > p.x &&
                        b.y < p.y + p.height && b.y + b.size > p.y);
            }

            // Paddle Hits
            if (checkCol(ball, player1) && ball.vx < 0) {
                ball.vx = -ball.vx * 1.05;
                let hitPoint = (ball.y + ball.size/2) - (player1.y + player1.height/2);
                ball.vy += hitPoint * 0.1; 
            }
            if (checkCol(ball, player2) && ball.vx > 0) {
                ball.vx = -ball.vx * 1.05;
                let hitPoint = (ball.y + ball.size/2) - (player2.y + player2.height/2);
                ball.vy += hitPoint * 0.1;
            }

            // Scoring
            if (ball.x < -50) {
                gameState.p2Score++;
                checkWin();
                resetBall();
            } else if (ball.x > canvas.width + 50) {
                gameState.p1Score++;
                checkWin();
                resetBall();
            }

            // Timer
            if (config.timeLimit > 0) {
                const elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
                gameState.timeLeft = Math.max(0, config.timeLimit - elapsed);
                if (gameState.timeLeft === 0) {
                    if (gameState.p1Score > gameState.p2Score) endGame('P1');
                    else if (gameState.p2Score > gameState.p1Score) endGame('P2');
                    else endGame('Tie');
                }
            }
        }

        function checkWin() {
            if (gameState.p1Score >= config.winScore) endGame('P1');
            if (gameState.p2Score >= config.winScore) endGame('P2');
        }

        function draw() {
            const isCyber = config.theme === 'cyber';
            
            // BG
            ctx.fillStyle = isCyber ? '#001122' : '#050505';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Net
            ctx.strokeStyle = '#333';
            ctx.setLineDash([10, 20]);
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(canvas.width/2, 0);
            ctx.lineTo(canvas.width/2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);

            // Glow
            ctx.shadowBlur = isCyber ? 20 : 0;

            // P1
            ctx.fillStyle = player1.color;
            ctx.shadowColor = player1.color;
            ctx.fillRect(player1.x, player1.y, player1.width, player1.height);

            // P2
            ctx.fillStyle = player2.color;
            ctx.shadowColor = player2.color;
            ctx.fillRect(player2.x, player2.y, player2.width, player2.height);

            // Ball
            ctx.fillStyle = ball.color;
            ctx.shadowColor = ball.color;
            ctx.fillRect(ball.x, ball.y, ball.size, ball.size);

            ctx.shadowBlur = 0;

            // HUD
            ctx.fillStyle = '#666';
            ctx.font = `60px "Press Start 2P"`;
            ctx.textAlign = 'center';
            // Adjust font size for mobile
            if (isMobile) ctx.font = `40px "Press Start 2P"`;
            
            ctx.fillText(gameState.p1Score, canvas.width * 0.25, canvas.height * 0.15);
            ctx.fillText(gameState.p2Score, canvas.width * 0.75, canvas.height * 0.15);

            if (config.timeLimit > 0) {
                ctx.fillStyle = gameState.timeLeft < 10 ? '#f00' : '#aaa';
                ctx.font = isMobile ? `20px "Press Start 2P"` : `30px "Press Start 2P"`;
                ctx.fillText(gameState.timeLeft, canvas.width/2, canvas.height * 0.1);
            }
        }

        function loop() {
            if (gameState.screen === 'playing') {
                update();
                draw();
                gameState.animationFrameId = requestAnimationFrame(loop);
            }
        }

    </script>
</body>
</html>